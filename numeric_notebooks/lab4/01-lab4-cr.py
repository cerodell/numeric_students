# %% [markdown]
# # Lab 4: Solving Ordinary Differential Equations with the Runge-Kutta Methods 
# ### Christopher Rordell
# ##### EOSC 511
# %% [markdown]
# ## Problem tableau 
#
# Write out the tableau for
# $$
# \\
# $$
# - 1\) Heun's Method
# $$
# \begin{array}{|c|c|c|c|}\hline i & {a_{i}} &  {b_{i j}} \hspace{1cm} &{c_{i}} \\ \hline 1 & {0} & {0} \hspace {1cm} {0} & {\frac{1}{4}} \\ {2} & {\frac{2}{3}} & {\frac{2}{3}} \hspace{1cm} {0} & {\frac{3}{4}} \\ \hline j=& {} & {1} \hspace{1cm} {2} & {} \\ \hline\end{array}
# $$
# $$
# \\
# $$
# - 2\) The fourth-order Runge-Kutta method
# $$
# \begin{array}{|c|c|c|c|}\hline i & {a_{i}} & {b_{i j}} \hspace{1cm} \hspace{1cm} \hspace{1cm} &{c_{i}} \\ \hline 1 & {0} & {0} \hspace{1cm} {0} \hspace{1cm} {0} \hspace{1cm} {0} & {\frac{1}{6}} \\ {2} & {\frac{1}{2}} & {\frac{1}{2}} \hspace{1cm} {0}  \hspace{1cm} {0} \hspace{1cm} {0} & {\frac{1}{3}}  \\ {3} & {\frac{1}{2}} & {0} \hspace{1cm} {\frac{1}{2}}  \hspace{1cm} {0} \hspace{1cm} {0} & {\frac{1}{3}}  \\ {4} & {1} & {0} \hspace{1cm} {0}  \hspace{1cm} {1} \hspace{1cm} {0} & {\frac{1}{6}} \\ \hline j=& {} & {1} \hspace{1cm} {2} \hspace{1cm} {3} \hspace{1cm} {4}& {} \\ \hline\end{array}
# $$
# %% [markdown]
# ## Problem Runge Kutta4     
# In the cell below, compare compare solutions to the test
# problem
# $$
# \\
# $$
# *EQ: Test*
# $$
# \frac{dy}{dt} = -y +t +1,  \;\;\;\; y(0) =1
# $$ 
# $$
# \\
# $$
# generated with the
# fourth-order Runge-Kutta method to solutions generated by the forward
# Euler and midpoint methods.
#
# 1.  Based on the numerical solutions of (EQ: Test), which of the
#     three methods appears more accurate?
#
# **Based on the numeric solution of Eq: Test the fourth-order 
# Runge-Kutta appears most accurate?**
#
# $$
# \\
# $$
# 2.  Again determine how the error changes relative to the change in
#     stepsize, as the stepsize is halved.
#
# **The error in all methods decreases as the step size decreases. 
#  However, Elure forward becomes much less stable than that of Runge-Kutta
#  and mid-point as the step size increase. In general, Runge-Kutta 
#  performs best and has the least error at the four-step sizes plotted.**
# %%
%matplotlib 
import context
import numpy as np
from matplotlib import pyplot as plt
from numlabs.lab4.lab4_functions import \
    initinter41,eulerinter41,midpointinter41, rk4ODEinter41

dt = [0.25, 0.20, 0.10, 0.05]
theFig=plt.figure(figsize = [10,10])
theFig.clf()

for stepsize in range(len(dt)):
    initialVals={'yinitial': 1,'t_beg':0.,'t_end':1.,'dt':dt[stepsize],'c1':-1.,'c2':1.,'c3':1.}
    coeff = initinter41(initialVals)
    timeVec=np.arange(coeff.t_beg,coeff.t_end,coeff.dt)
    nsteps=len(timeVec)
    ye=[]
    ym=[]
    yrk=[]
    y=coeff.yinitial
    ye.append(coeff.yinitial)
    ym.append(coeff.yinitial)
    yrk.append(coeff.yinitial)
    for i in np.arange(1,nsteps):
        ynew=eulerinter41(coeff,y,timeVec[i-1])
        ye.append(ynew)
        ynew=midpointinter41(coeff,y,timeVec[i-1])
        ym.append(ynew)
        ynew=rk4ODEinter41(coeff,y,timeVec[i-1])
        yrk.append(ynew)
        y=ynew
    analytic=timeVec + np.exp(-timeVec)
    theAx=theFig.add_subplot(2, 2, (stepsize +1))
    l1=theAx.plot(timeVec,analytic,'b-',label='analytic')
    theAx.set_xlabel('time (seconds)')
    l2=theAx.plot(timeVec,ye,'r-',label='euler')
    l3=theAx.plot(timeVec,ym,'g-',label='midpoint')
    l4=theAx.plot(timeVec,yrk,'m-',label='rk4')
    theAx.legend(loc='best')
    theAx.set_title('interactive 4.2 dt: ' + str(dt[stepsize]))

# %% [markdown]

# ## Problem embedded
# Though the error estimate is for the embedded fourth-order Runge-Kutta method, 
# the fifth-order method can be used in practice for calculating the solution, 
# the assumption being the fifth-order method should be at least as accurate as 
# the fourth-order method. In the demo below, compare solutions of the test problem EQ:test
# $$
# \\
# $$
# *EQ: Test*
# $$
# \frac{dy}{dt} = -y +t +1,  \;\;\;\; y(0) =1
# $$ 
# $$
# \\
# $$
# - a\) Which method is more accurate?
#
# **The Runge-Kutta initialize with the Cash-Karp coefficients (RKCK) 
# was more accurate at each time steep.....though you need to zoom in 
# to view on the order of 10^-6 to see a discernible difference.**
#
# $$
# \\
# $$
#
# - b\) Again, determine how the error decreases as you halve the stepsizes.
#
# **Again, error in all methods decreases as the step size decreases. However, 
#  in this case, Runge-Kutta not initialized with the Cash-Karp coefficients
#  (RK) had a tinny bit more error than RKCK.**

# %%
from numlabs.lab4.lab4_functions import initinter41,rk4ODEinter41,rkckODEinter41

dt = [0.4, 0.20, 0.10, 0.05]
theFig=plt.figure(figsize = [10,10])
theFig.clf()

for stepsize in range(len(dt)):
    initialVals={'yinitial': 1,'t_beg':0.,'t_end':1.,'dt':dt[stepsize],'c1':-1.,'c2':1.,'c3':1.}
    coeff = initinter41(initialVals)
    timeVec=np.arange(coeff.t_beg,coeff.t_end,coeff.dt)
    nsteps=len(timeVec)
    ye=[]
    ym=[]
    yrk=[]
    yrkck=[]
    y1=coeff.yinitial
    y2=coeff.yinitial
    yrk.append(coeff.yinitial)
    yrkck.append(coeff.yinitial)
    for i in np.arange(1,nsteps):
        ynew=rk4ODEinter41(coeff,y1,timeVec[i-1])
        yrk.append(ynew)
        y1=ynew
        ynew=rkckODEinter41(coeff,y2,timeVec[i-1])
        yrkck.append(ynew)
        y2=ynew
    analytic=timeVec + np.exp(-timeVec)
    theAx=theFig.add_subplot(2, 2, (stepsize +1))
    l1=theAx.plot(timeVec,analytic,'b-',label='analytic', lw = 2, alpha = 0.3)
    theAx.set_xlabel('time (seconds)')
    l2=theAx.plot(timeVec,yrkck,'g-',label='rkck')
    l3=theAx.plot(timeVec,yrk,'m-',label='rk')
    theAx.legend(loc='best')
    theAx.set_title('interactive 4.3 dt:  ' + str(dt[stepsize]))

# %% [markdown]

# ## Problem coding A
# As set up above, do_example.py solves the damped, harmonic 
# oscillator with the (unstable) forward Euler method.
#
# - 1\) Write a new routine that solves the harmonic oscilator 
# using Heunâ€™s method along the lines of the routines in lab4_functions.py
#  Hand in a fresh notebook with the code and a plot.
# %%



# %%
import json
from numlabs.lab4.example.do_example import get_init,euler4

def heun(coeff, y, derivs):
  k1 = coeff.dt * derivs(coeff,y)
  k2 = coeff.dt * derivs(coeff,y + ((2/3) * k1))
  ynew = y + (1.0/6.0) * (k1 + (2.0 * k2) + (2.0 * k3) + k4)
  return ynew


#
# specify the derivs function
#
def derivs(coeff, y):
  f=np.empty_like(y) #create a 2 element vector to hold the derivitive
  f[0]=y[1]
  f[1]= -1.*coeff.c1*y[1] - coeff.c2*y[0]
  return f
#
# first make sure we have an input file in this directory
#

coeff=get_init()

#
# integrate and save the result in savedata
#
time=np.arange(coeff.t_beg,coeff.t_end,coeff.dt)
y=coeff.yinitial
nsteps=len(time)
savedata=np.empty([nsteps],np.float64)
for i in range(nsteps):
    y=euler4(coeff,y,derivs)
    savedata[i]=y[0]

theFig,theAx=plt.subplots(1,1,figsize=(8,8))
theAx.plot(time,savedata,'o-')
theAx.set_title(coeff.plot_title)
theAx.set_xlabel('time (seconds)')
theAx.set_ylabel('y0')

# %%
