# %% [markdown]
# # Lab 4: Solving Ordinary Differential Equations with the Runge-Kutta Methods 
# ### Christopher Rordell
# ##### EOSC 511
# %% [markdown]
# ## Problem tableau 
#
# Write out the tableau for
# $$
# \\
# $$
# - 1\) Heun's Method
# $$
# \begin{array}{|c|c|c|c|}\hline i & {a_{i}} &  {b_{i j}} \hspace{1cm} &{c_{i}} \\ \hline 1 & {0} & {0} \hspace {1cm} {0} & {\frac{1}{4}} \\ {2} & {\frac{2}{3}} & {\frac{2}{3}} \hspace{1cm} {0} & {\frac{3}{4}} \\ \hline j=& {} & {1} \hspace{1cm} {2} & {} \\ \hline\end{array}
# $$
# $$
# \\
# $$
# - 2\) The fourth-order Runge-Kutta method
# $$
# \begin{array}{|c|c|c|c|}\hline i & {a_{i}} & {b_{i j}} \hspace{1cm} \hspace{1cm} \hspace{1cm} &{c_{i}} \\ \hline 1 & {0} & {0} \hspace{1cm} {0} \hspace{1cm} {0} \hspace{1cm} {0} & {\frac{1}{6}} \\ {2} & {\frac{1}{2}} & {\frac{1}{2}} \hspace{1cm} {0}  \hspace{1cm} {0} \hspace{1cm} {0} & {\frac{1}{3}}  \\ {3} & {\frac{1}{2}} & {0} \hspace{1cm} {\frac{1}{2}}  \hspace{1cm} {0} \hspace{1cm} {0} & {\frac{1}{3}}  \\ {4} & {1} & {0} \hspace{1cm} {0}  \hspace{1cm} {1} \hspace{1cm} {0} & {\frac{1}{6}} \\ \hline j=& {} & {1} \hspace{1cm} {2} \hspace{1cm} {3} \hspace{1cm} {4}& {} \\ \hline\end{array}
# $$
# %% [markdown]
# ## Problem Runge Kutta4     
# In the cell below, compare compare solutions to the test
# problem
# $$
# \\
# $$
# *EQ: Test*
# $$
# \frac{dy}{dt} = -y +t +1,  \;\;\;\; y(0) =1
# $$ 
# $$
# \\
# $$
# generated with the
# fourth-order Runge-Kutta method to solutions generated by the forward
# Euler and midpoint methods.
#
# 1.  Based on the numerical solutions of (EQ: Test), which of the
#     three methods appears more accurate?
#
# **Based on the numeric solution of Eq: Test the fourth-order 
# Runge-Kutta appears most accurate.**
#
# 2.  Again determine how the error changes relative to the change in
#     stepsize, as the stepsize is halved.
# %%
%matplotlib 
import context
import numpy as np
from matplotlib import pyplot as plt
from numlabs.lab4.lab4_functions import \
    initinter41,eulerinter41,midpointinter41, rk4ODEinter41

dt = [0.25, 0.20, 0.10, 0.05]
theFig=plt.figure(figsize = [10,10])
theFig.clf()

for stepsize in range(len(dt)):
    initialVals={'yinitial': 1,'t_beg':0.,'t_end':1.,'dt':dt[stepsize],'c1':-1.,'c2':1.,'c3':1.}
    coeff = initinter41(initialVals)
    timeVec=np.arange(coeff.t_beg,coeff.t_end,coeff.dt)
    nsteps=len(timeVec)
    ye=[]
    ym=[]
    yrk=[]
    y=coeff.yinitial
    ye.append(coeff.yinitial)
    ym.append(coeff.yinitial)
    yrk.append(coeff.yinitial)
    for i in np.arange(1,nsteps):
        ynew=eulerinter41(coeff,y,timeVec[i-1])
        ye.append(ynew)
        ynew=midpointinter41(coeff,y,timeVec[i-1])
        ym.append(ynew)
        ynew=rk4ODEinter41(coeff,y,timeVec[i-1])
        yrk.append(ynew)
        y=ynew
    analytic=timeVec + np.exp(-timeVec)
    theAx=theFig.add_subplot(2, 2, (stepsize +1))
    l1=theAx.plot(timeVec,analytic,'b-',label='analytic')
    theAx.set_xlabel('time (seconds)')
    l2=theAx.plot(timeVec,ye,'r-',label='euler')
    l3=theAx.plot(timeVec,ym,'g-',label='midpoint')
    l4=theAx.plot(timeVec,yrk,'m-',label='rk4')
    theAx.legend(loc='best')
    theAx.set_title('interactive 4.2 dt: ' + str(dt[stepsize]))

# %%




